/*
 * ex: set ro:
 * DO NOT EDIT.
 * generated by smc (http://smc.sourceforge.net/)
 * from file : SmcParser.sm
 */


/*
 * The contents of this file are subject to the Mozilla Public
 * License Version 1.1 (the "License"); you may not use this file
 * except in compliance with the License. You may obtain a copy
 * of the License at http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an
 * "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, either express or
 * implied. See the License for the specific language governing
 * rights and limitations under the License.
 *
 * The Original Code is State Machine Compiler (SMC).
 *
 * The Initial Developer of the Original Code is Charles W. Rapp.
 * Portions created by Charles W. Rapp are
 * Copyright (C) 2000 - 2005, 2008, 2013. Charles W. Rapp.
 * All Rights Reserved.
 *
 * Contributor(s):
 *   Eitan Suez contributed examples/Ant.
 *   (Name withheld) contributed the C# code generation and
 *   examples/C#.
 *   Francois Perrad contributed the Python code generation and
 *   examples/Python, Perl code generation and examples/Perl,
 *   Ruby code generation and examples/Ruby, Lua code generation
 *   and examples/Lua, Groovy code generation and examples/Groovy.
 *   Chris Liscio contributed the Objective-C code generation
 *   and examples/ObjC.
 *
 * smcParser --
 *
 *  This state machine defines the  state machine language.
 *
 * RCS ID
 * $Id: SmcParser.sm,v 1.9 2013/12/15 16:31:20 fperrad Exp $
 *
 * CHANGE LOG
 * $Log: SmcParser.sm,v $
 * Revision 1.9  2013/12/15 16:31:20  fperrad
 * full refactor of JavaScript
 *
 * Revision 1.8  2013/07/14 14:32:39  cwrapp
 * check in for release 6.2.0
 *
 * Revision 1.7  2010/03/05 21:29:54  fperrad
 * Allows property with Groovy, Lua, Perl, Python, Ruby & Scala
 *
 * Revision 1.6  2010/03/03 19:18:41  fperrad
 * fix property with Graph & Table
 *
 * Revision 1.5  2009/09/12 21:44:49  kgreg99
 * Implemented feature req. #2718941 - user defined generated class name.
 * A new statement was added to the syntax: %fsmclass class_name
 * It is optional. If not used, generated class is called as before "XxxContext" where Xxx is context class name as entered via %class statement.
 * If used, generated class is called asrequested.
 * Following language generators are touched:
 * c, c++, java, c#, objc, lua, groovy, scala, tcl, VB
 * This feature is not tested yet !
 * Maybe it will be necessary to modify also the output file name.
 *
 * Revision 1.4  2009/04/11 13:11:13  cwrapp
 * Corrected raw mode 3 to handle multiple argument template/generic declarations.
 *
 * Revision 1.3  2009/03/27 09:41:47  cwrapp
 * Added F. Perrad changes back in.
 *
 * Revision 1.2  2009/03/03 17:28:53  kgreg99
 * 1. Bugs resolved:
 * #2657779 - modified SmcParser.sm and SmcParserContext.java
 * #2648516 - modified SmcCSharpGenerator.java
 * #2648472 - modified SmcSyntaxChecker.java
 * #2648469 - modified SmcMap.java
 *
 * Revision 1.1  2009/03/01 18:20:42  cwrapp
 * Preliminary v. 6.0.0 commit.
 *
 * Revision 1.21  2008/08/16 14:31:37  fperrad
 * + detabify
 *
 * Revision 1.20  2008/04/22 16:05:24  fperrad
 * - add PHP language (patch from Toni Arnold)
 *
 * Revision 1.19  2008/01/22 08:56:55  fperrad
 * - fix : allows Perl parameter with graph generation
 *
 * Revision 1.18  2007/11/19 18:53:21  fperrad
 * + add : jump syntax
 *   jump uses the same syntax as push,
 *   allows transition between states of different maps but without stacking a return context.
 *
 * Revision 1.17  2007/07/16 06:28:06  fperrad
 * + Added Groovy generator.
 *
 * Revision 1.16  2007/02/21 13:56:16  cwrapp
 * Moved Java code to release 1.5.0
 *
 * Revision 1.15  2007/01/15 00:23:51  cwrapp
 * Release 4.4.0 initial commit.
 *
 * Revision 1.14  2007/01/03 15:23:05  fperrad
 * + Added Lua generator.
 *
 * Revision 1.13  2006/09/16 15:04:29  cwrapp
 * Initial v. 4.3.3 check-in.
 *
 * Revision 1.12  2006/07/11 18:17:01  cwrapp
 * Removed errors regarding percent keywords.
 *
 * Revision 1.11  2006/04/22 12:45:26  cwrapp
 * Version 4.3.1
 *
 * Revision 1.10  2005/09/14 01:51:33  cwrapp
 * Changes in release 4.2.0:
 * New features:
 *
 * None.
 *
 * Fixed the following bugs:
 *
 * + (Java) -java broken due to an untested minor change.
 *
 * Revision 1.9  2005/08/26 15:21:34  cwrapp
 * Final commit for release 4.2.0. See README.txt for more information.
 *
 * Revision 1.8  2005/07/07 12:11:56  fperrad
 * Add a new token '$' for Perl language.
 * The type of parameter is optional for Python, Per & Ruby.
 *
 * Revision 1.7  2005/06/30 10:44:23  cwrapp
 * Added %access keyword which allows developers to set the generate Context
 * class' accessibility level in Java and C#.
 *
 * Revision 1.6  2005/05/28 19:28:42  cwrapp
 * Moved to visitor pattern.
 *
 * Revision 1.5  2005/02/21 15:37:52  charlesr
 * Added Francois Perrad to Contributors section for Python work.
 *
 * Revision 1.4  2005/02/21 15:21:21  charlesr
 * Added -graph target as allowing %include, %declare and %import.
 *
 * Revision 1.3  2005/02/03 17:06:21  charlesr
 * SmcParser.warning() and .error() methods now take a line
 * number argument. All calls to these method within the
 * parser's FSM have been modified.
 *
 * Revision 1.2  2004/09/06 16:41:32  charlesr
 * Added "property = value" syntax. Added C# support.
 *
 * Revision 1.1  2004/05/31 13:56:34  charlesr
 * Added support for VB.net code generation.
 *
 * Revision 1.0  2003/12/14 21:06:00  charlesr
 * Initial revision
 *
 */


package net.sf.smc.parser;

import java.util.List;
import net.sf.smc.model.SmcAction;
import net.sf.smc.model.SmcElement.TransType;
import net.sf.smc.model.SmcFSM;
import net.sf.smc.model.SmcGuard;
import net.sf.smc.model.SmcMap;
import net.sf.smc.model.SmcParameter;
import net.sf.smc.model.SmcTransition;
import net.sf.smc.parser.SmcParser.TargetLanguage;

public class SmcParserContext
    extends statemap.FSMContext
{
//---------------------------------------------------------------
// Member methods.
//

    public SmcParserContext(SmcParser owner)
    {
        this (owner, ParserMap.Start);
    }

    public SmcParserContext(SmcParser owner, SmcParserState initState)
    {
        super (initState);

        _owner = owner;
    }

    @Override
    public void enterStartState()
    {
        getState().entry(this);
        return;
    }

    public void ACCESS(SmcLexer.Token token)
    {
        _transition = "ACCESS";
        getState().ACCESS(this, token);
        _transition = "";
        return;
    }

    public void CLASS_NAME(SmcLexer.Token token)
    {
        _transition = "CLASS_NAME";
        getState().CLASS_NAME(this, token);
        _transition = "";
        return;
    }

    public void COLON(SmcLexer.Token token)
    {
        _transition = "COLON";
        getState().COLON(this, token);
        _transition = "";
        return;
    }

    public void COMMA(SmcLexer.Token token)
    {
        _transition = "COMMA";
        getState().COMMA(this, token);
        _transition = "";
        return;
    }

    public void DECLARE(SmcLexer.Token token)
    {
        _transition = "DECLARE";
        getState().DECLARE(this, token);
        _transition = "";
        return;
    }

    public void DOLLAR(SmcLexer.Token token)
    {
        _transition = "DOLLAR";
        getState().DOLLAR(this, token);
        _transition = "";
        return;
    }

    public void ENTRY(SmcLexer.Token token)
    {
        _transition = "ENTRY";
        getState().ENTRY(this, token);
        _transition = "";
        return;
    }

    public void EOD(SmcLexer.Token token)
    {
        _transition = "EOD";
        getState().EOD(this, token);
        _transition = "";
        return;
    }

    public void EQUAL(SmcLexer.Token token)
    {
        _transition = "EQUAL";
        getState().EQUAL(this, token);
        _transition = "";
        return;
    }

    public void EXIT(SmcLexer.Token token)
    {
        _transition = "EXIT";
        getState().EXIT(this, token);
        _transition = "";
        return;
    }

    public void FSM_CLASS_NAME(SmcLexer.Token token)
    {
        _transition = "FSM_CLASS_NAME";
        getState().FSM_CLASS_NAME(this, token);
        _transition = "";
        return;
    }

    public void HEADER_FILE(SmcLexer.Token token)
    {
        _transition = "HEADER_FILE";
        getState().HEADER_FILE(this, token);
        _transition = "";
        return;
    }

    public void IMPORT(SmcLexer.Token token)
    {
        _transition = "IMPORT";
        getState().IMPORT(this, token);
        _transition = "";
        return;
    }

    public void INCLUDE_FILE(SmcLexer.Token token)
    {
        _transition = "INCLUDE_FILE";
        getState().INCLUDE_FILE(this, token);
        _transition = "";
        return;
    }

    public void JUMP(SmcLexer.Token token)
    {
        _transition = "JUMP";
        getState().JUMP(this, token);
        _transition = "";
        return;
    }

    public void LEFT_BRACE(SmcLexer.Token token)
    {
        _transition = "LEFT_BRACE";
        getState().LEFT_BRACE(this, token);
        _transition = "";
        return;
    }

    public void LEFT_BRACKET(SmcLexer.Token token)
    {
        _transition = "LEFT_BRACKET";
        getState().LEFT_BRACKET(this, token);
        _transition = "";
        return;
    }

    public void LEFT_PAREN(SmcLexer.Token token)
    {
        _transition = "LEFT_PAREN";
        getState().LEFT_PAREN(this, token);
        _transition = "";
        return;
    }

    public void MAP_NAME(SmcLexer.Token token)
    {
        _transition = "MAP_NAME";
        getState().MAP_NAME(this, token);
        _transition = "";
        return;
    }

    public void PACKAGE_NAME(SmcLexer.Token token)
    {
        _transition = "PACKAGE_NAME";
        getState().PACKAGE_NAME(this, token);
        _transition = "";
        return;
    }

    public void POP(SmcLexer.Token token)
    {
        _transition = "POP";
        getState().POP(this, token);
        _transition = "";
        return;
    }

    public void PUSH(SmcLexer.Token token)
    {
        _transition = "PUSH";
        getState().PUSH(this, token);
        _transition = "";
        return;
    }

    public void RIGHT_BRACE(SmcLexer.Token token)
    {
        _transition = "RIGHT_BRACE";
        getState().RIGHT_BRACE(this, token);
        _transition = "";
        return;
    }

    public void RIGHT_PAREN(SmcLexer.Token token)
    {
        _transition = "RIGHT_PAREN";
        getState().RIGHT_PAREN(this, token);
        _transition = "";
        return;
    }

    public void SEMICOLON(SmcLexer.Token token)
    {
        _transition = "SEMICOLON";
        getState().SEMICOLON(this, token);
        _transition = "";
        return;
    }

    public void SLASH(SmcLexer.Token token)
    {
        _transition = "SLASH";
        getState().SLASH(this, token);
        _transition = "";
        return;
    }

    public void SOURCE(SmcLexer.Token token)
    {
        _transition = "SOURCE";
        getState().SOURCE(this, token);
        _transition = "";
        return;
    }

    public void START_STATE(SmcLexer.Token token)
    {
        _transition = "START_STATE";
        getState().START_STATE(this, token);
        _transition = "";
        return;
    }

    public void WORD(SmcLexer.Token token)
    {
        _transition = "WORD";
        getState().WORD(this, token);
        _transition = "";
        return;
    }

    public void actionsDone(List<SmcAction> actions, int lineNumber)
    {
        _transition = "actionsDone";
        getState().actionsDone(this, actions, lineNumber);
        _transition = "";
        return;
    }

    public void actionsError()
    {
        _transition = "actionsError";
        getState().actionsError(this);
        _transition = "";
        return;
    }

    public void argsDone(List<String> args)
    {
        _transition = "argsDone";
        getState().argsDone(this, args);
        _transition = "";
        return;
    }

    public void argsError()
    {
        _transition = "argsError";
        getState().argsError(this);
        _transition = "";
        return;
    }

    public void paramsDone(List<SmcParameter> params, int lineNumber)
    {
        _transition = "paramsDone";
        getState().paramsDone(this, params, lineNumber);
        _transition = "";
        return;
    }

    public void paramsError(List<SmcParameter> params, int lineNumber)
    {
        _transition = "paramsError";
        getState().paramsError(this, params, lineNumber);
        _transition = "";
        return;
    }

    public SmcParserState getState()
        throws statemap.StateUndefinedException
    {
        if (_state == null)
        {
            throw(
                new statemap.StateUndefinedException());
        }

        return ((SmcParserState) _state);
    }

    protected SmcParser getOwner()
    {
        return (_owner);
    }

    public void setOwner(SmcParser owner)
    {
        if (owner == null)
        {
            throw (
                new NullPointerException(
                    "null owner"));
        }
        else
        {
            _owner = owner;
        }

        return;
    }

//---------------------------------------------------------------
// Member data.
//

    transient private SmcParser _owner;

    //-----------------------------------------------------------
    // Constants.
    //

    private static final long serialVersionUID = 1L;

//---------------------------------------------------------------
// Inner classes.
//

    public static abstract class SmcParserState
        extends statemap.State
    {
    //-----------------------------------------------------------
    // Member methods.
    //

        protected SmcParserState(String name, int id)
        {
            super (name, id);
        }

        protected void entry(SmcParserContext context) {}
        protected void exit(SmcParserContext context) {}

        protected void ACCESS(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void CLASS_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void COLON(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void COMMA(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void DECLARE(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void DOLLAR(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void ENTRY(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void EOD(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void EQUAL(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void EXIT(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void FSM_CLASS_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void HEADER_FILE(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void IMPORT(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void INCLUDE_FILE(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void JUMP(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void LEFT_BRACKET(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void MAP_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void PACKAGE_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void POP(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void PUSH(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void RIGHT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void SEMICOLON(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void SLASH(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void START_STATE(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            Default(context);
        }

        protected void actionsDone(SmcParserContext context, List<SmcAction> actions, int lineNumber)
        {
            Default(context);
        }

        protected void actionsError(SmcParserContext context)
        {
            Default(context);
        }

        protected void argsDone(SmcParserContext context, List<String> args)
        {
            Default(context);
        }

        protected void argsError(SmcParserContext context)
        {
            Default(context);
        }

        protected void paramsDone(SmcParserContext context, List<SmcParameter> params, int lineNumber)
        {
            Default(context);
        }

        protected void paramsError(SmcParserContext context, List<SmcParameter> params, int lineNumber)
        {
            Default(context);
        }

        protected void Default(SmcParserContext context)
        {
            throw (
                new statemap.TransitionUndefinedException(
                    "State: " +
                    context.getState().getName() +
                    ", Transition: " +
                    context.getTransition()));
        }

    //-----------------------------------------------------------
    // Member data.
    //
    }

    /* package */ static abstract class ParserMap
    {
    //-----------------------------------------------------------
    // Member methods.
    //

    //-----------------------------------------------------------
    // Member data.
    //

        //-------------------------------------------------------
        // Constants.
        //

        public static final ParserMap_Start Start =
            new ParserMap_Start("ParserMap.Start", 0);
        public static final ParserMap_Context Context =
            new ParserMap_Context("ParserMap.Context", 1);
        public static final ParserMap_StartState StartState =
            new ParserMap_StartState("ParserMap.StartState", 2);
        public static final ParserMap_HeaderFile HeaderFile =
            new ParserMap_HeaderFile("ParserMap.HeaderFile", 3);
        public static final ParserMap_IncludeFile IncludeFile =
            new ParserMap_IncludeFile("ParserMap.IncludeFile", 4);
        public static final ParserMap_Package Package =
            new ParserMap_Package("ParserMap.Package", 5);
        public static final ParserMap_FsmClassName FsmClassName =
            new ParserMap_FsmClassName("ParserMap.FsmClassName", 6);
        public static final ParserMap_Import Import =
            new ParserMap_Import("ParserMap.Import", 7);
        public static final ParserMap_Declare Declare =
            new ParserMap_Declare("ParserMap.Declare", 8);
        public static final ParserMap_Access Access =
            new ParserMap_Access("ParserMap.Access", 9);
        public static final ParserMap_StartError StartError =
            new ParserMap_StartError("ParserMap.StartError", 10);
        public static final ParserMap_MapStart MapStart =
            new ParserMap_MapStart("ParserMap.MapStart", 11);
        public static final ParserMap_MapStartError MapStartError =
            new ParserMap_MapStartError("ParserMap.MapStartError", 12);
        public static final ParserMap_MapName MapName =
            new ParserMap_MapName("ParserMap.MapName", 13);
        public static final ParserMap_MapStates MapStates =
            new ParserMap_MapStates("ParserMap.MapStates", 14);
        public static final ParserMap_MapStatesError MapStatesError =
            new ParserMap_MapStatesError("ParserMap.MapStatesError", 15);
        public static final ParserMap_States States =
            new ParserMap_States("ParserMap.States", 16);
        public static final ParserMap_StateStart StateStart =
            new ParserMap_StateStart("ParserMap.StateStart", 17);
        public static final ParserMap_StateStartError StateStartError =
            new ParserMap_StateStartError("ParserMap.StateStartError", 18);
        public static final ParserMap_EntryStart EntryStart =
            new ParserMap_EntryStart("ParserMap.EntryStart", 19);
        public static final ParserMap_EntryEnd EntryEnd =
            new ParserMap_EntryEnd("ParserMap.EntryEnd", 20);
        public static final ParserMap_ExitStart ExitStart =
            new ParserMap_ExitStart("ParserMap.ExitStart", 21);
        public static final ParserMap_ExitEnd ExitEnd =
            new ParserMap_ExitEnd("ParserMap.ExitEnd", 22);
        public static final ParserMap_Transitions Transitions =
            new ParserMap_Transitions("ParserMap.Transitions", 23);
        public static final ParserMap_TransError TransError =
            new ParserMap_TransError("ParserMap.TransError", 24);
        public static final ParserMap_TransStart TransStart =
            new ParserMap_TransStart("ParserMap.TransStart", 25);
        public static final ParserMap_TransStartError TransStartError =
            new ParserMap_TransStartError("ParserMap.TransStartError", 26);
        public static final ParserMap_TransParams TransParams =
            new ParserMap_TransParams("ParserMap.TransParams", 27);
        public static final ParserMap_TransNext TransNext =
            new ParserMap_TransNext("ParserMap.TransNext", 28);
        public static final ParserMap_TransNextError TransNextError =
            new ParserMap_TransNextError("ParserMap.TransNextError", 29);
        public static final ParserMap_TransGuard TransGuard =
            new ParserMap_TransGuard("ParserMap.TransGuard", 30);
        public static final ParserMap_EndState EndState =
            new ParserMap_EndState("ParserMap.EndState", 31);
        public static final ParserMap_EndStateError EndStateError =
            new ParserMap_EndStateError("ParserMap.EndStateError", 32);
        public static final ParserMap_SimpleTrans SimpleTrans =
            new ParserMap_SimpleTrans("ParserMap.SimpleTrans", 33);
        public static final ParserMap_PushTransition PushTransition =
            new ParserMap_PushTransition("ParserMap.PushTransition", 34);
        public static final ParserMap_PushStart PushStart =
            new ParserMap_PushStart("ParserMap.PushStart", 35);
        public static final ParserMap_PushError PushError =
            new ParserMap_PushError("ParserMap.PushError", 36);
        public static final ParserMap_PushMap PushMap =
            new ParserMap_PushMap("ParserMap.PushMap", 37);
        public static final ParserMap_PushEnd PushEnd =
            new ParserMap_PushEnd("ParserMap.PushEnd", 38);
        public static final ParserMap_JumpStart JumpStart =
            new ParserMap_JumpStart("ParserMap.JumpStart", 39);
        public static final ParserMap_JumpError JumpError =
            new ParserMap_JumpError("ParserMap.JumpError", 40);
        public static final ParserMap_JumpMap JumpMap =
            new ParserMap_JumpMap("ParserMap.JumpMap", 41);
        public static final ParserMap_JumpEnd JumpEnd =
            new ParserMap_JumpEnd("ParserMap.JumpEnd", 42);
        public static final ParserMap_PopStart PopStart =
            new ParserMap_PopStart("ParserMap.PopStart", 43);
        public static final ParserMap_PopError PopError =
            new ParserMap_PopError("ParserMap.PopError", 44);
        public static final ParserMap_PopAction PopAction =
            new ParserMap_PopAction("ParserMap.PopAction", 45);
        public static final ParserMap_PopArgs PopArgs =
            new ParserMap_PopArgs("ParserMap.PopArgs", 46);
        public static final ParserMap_PopArgsEnd PopArgsEnd =
            new ParserMap_PopArgsEnd("ParserMap.PopArgsEnd", 47);
        public static final ParserMap_ActionStart ActionStart =
            new ParserMap_ActionStart("ParserMap.ActionStart", 48);
        public static final ParserMap_ActionEnd ActionEnd =
            new ParserMap_ActionEnd("ParserMap.ActionEnd", 49);
        public static final ParserMap_ActionStartError ActionStartError =
            new ParserMap_ActionStartError("ParserMap.ActionStartError", 50);
    }

    protected static class ParserMap_Default
        extends SmcParserState
    {
    //-----------------------------------------------------------
    // Member methods.
    //

        protected ParserMap_Default(String name, int id)
        {
            super (name, id);
        }

    //-----------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_Start
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_Start(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void ACCESS(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Access);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void CLASS_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Context);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void DECLARE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Declare);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting \"%{ source %}\", %start, or %class.", ctxt.getLineNumber());
                ctxt.setHeaderLine(ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void FSM_CLASS_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.FsmClassName);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void HEADER_FILE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.HeaderFile);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void IMPORT(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Import);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void INCLUDE_FILE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.IncludeFile);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void MAP_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (ctxt.isValidHeader() == true)
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.setHeaderLine(token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.MapName);
                    (context.getState()).entry(context);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.error("%map not preceded by %start and %class.", token.getLineNumber());
                    ctxt.setHeaderLine(token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.StartError);
                    (context.getState()).entry(context);
                }

            }

            return;
        }

        @Override
        protected void PACKAGE_NAME(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.Package);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            SmcParserState endState = context.getState();
            context.clearState();
            try
            {
                ctxt.setSource(token.getValue());
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(endState);
            }

            return;
        }

        @Override
        protected void START_STATE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartState);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_Context
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_Context(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Missing name after %class.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setContext(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_StartState
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_StartState(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Missing state after %start.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (ctxt.isValidStartState(token.getValue()) == true)
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.setStartState(token.getValue());
                }
                finally
                {
                    context.setState(ParserMap.Start);
                    (context.getState()).entry(context);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.error("Start state must be of the form \"map::state\".", token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.StartError);
                    (context.getState()).entry(context);
                }

            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_HeaderFile
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_HeaderFile(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("\n\r\f");
            return;
        }

        @Override
        protected void exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Missing header file after %header.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeader(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_IncludeFile
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_IncludeFile(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("\n\r\f");
            return;
        }

        @Override
        protected void exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Missing include file after %include.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.addInclude(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_Package
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_Package(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Missing name after %package.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setPackageName(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_FsmClassName
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_FsmClassName(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Missing name after %FsmClassName.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setFsmClassName(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_Import
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_Import(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("\n\r\f");
            return;
        }

        @Override
        protected void exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Missing name after %import.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.addImport(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_Declare
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_Declare(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("\n\r\f");
            return;
        }

        @Override
        protected void exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Missing name after %declare.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.addDeclare(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_Access
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_Access(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("\n\r\f");
            return;
        }

        @Override
        protected void exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Missing access level after %access.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setAccessLevel(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_StartError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_StartError(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void ACCESS(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.Access);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void CLASS_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Context);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void DECLARE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Declare);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void Default(SmcParserContext context)
        {

            return;
        }

        @Override
        protected void FSM_CLASS_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.FsmClassName);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void HEADER_FILE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.HeaderFile);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void IMPORT(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Import);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void MAP_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (ctxt.isValidHeader() == true)
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.setHeaderLine(token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.MapName);
                    (context.getState()).entry(context);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.error("%map not preceded by %start and %class.", token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.StartError);
                    (context.getState()).entry(context);
                }

            }

            return;
        }

        @Override
        protected void PACKAGE_NAME(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.Package);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void START_STATE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setHeaderLine(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StartState);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_MapStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_MapStart(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting %map.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.MapStartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void MAP_NAME(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.MapName);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_MapStartError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_MapStartError(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {

            return;
        }

        @Override
        protected void MAP_NAME(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.MapName);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_MapName
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_MapName(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            SmcParserState endState = context.getState();
            context.clearState();
            try
            {
                ctxt.error("Name expected after \"%map\".", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(endState);
            }

            return;
        }

        @Override
        protected void EOD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Name expected after \"%map\".", token.getLineNumber());
                ctxt.createMap(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.States);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (ctxt.isDuplicateMap(token.getValue()) == true)
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.error("Duplicate map name.", token.getLineNumber());
                    ctxt.createMap(token.getValue(), token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.MapStates);
                    (context.getState()).entry(context);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.createMap(token.getValue(), token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.MapStates);
                    (context.getState()).entry(context);
                }

            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_MapStates
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_MapStates(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting %% after \"%map mapname\".", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.MapStatesError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void EOD(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.States);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting %% after \"%map mapname\".", token.getLineNumber());
                ctxt.createState(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StateStart);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_MapStatesError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_MapStatesError(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {

            return;
        }

        @Override
        protected void EOD(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.States);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void MAP_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.addMap();
            }
            finally
            {
                context.setState(ParserMap.MapName);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createState(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StateStart);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_States
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_States(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            SmcParserState endState = context.getState();
            context.clearState();
            try
            {
                ctxt.error("Expecting either a new state definition or end of map (%%).", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(endState);
            }

            return;
        }

        @Override
        protected void ENTRY(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
                ctxt.createState(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.EntryStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void EOD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.addMap();
            }
            finally
            {
                context.setState(ParserMap.MapStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void EQUAL(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
                ctxt.createState(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Transitions);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void EXIT(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
                ctxt.createState(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.ExitStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting either a new state definition or end of map (%%).", token.getLineNumber());
                ctxt.createState(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.Transitions);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void MAP_NAME(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting \"%%\" before another \"%map\".", token.getLineNumber());
                ctxt.addMap();
            }
            finally
            {
                context.setState(ParserMap.MapName);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (ctxt.isDuplicateState(token.getValue()) == true)
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.error("Duplicate state name.", token.getLineNumber());
                    ctxt.createState(token.getValue(), token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.StateStart);
                    (context.getState()).entry(context);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.createState(token.getValue(), token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.StateStart);
                    (context.getState()).entry(context);
                }

            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_StateStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_StateStart(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("After the state name is given, then either an entry action, exit action or opening brace is expected.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StateStartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void ENTRY(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (ctxt.isDefaultState() == true)
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.error("Default state may not have an entry action.", token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.EntryStart);
                    (context.getState()).entry(context);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.setState(ParserMap.EntryStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void EXIT(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (ctxt.isDefaultState() == true)
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.error("Default state may not have an exit action.", token.getLineNumber());
                }
                finally
                {
                    context.setState(ParserMap.ExitStart);
                    (context.getState()).entry(context);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.setState(ParserMap.ExitStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.Transitions);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_StateStartError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_StateStartError(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {

            return;
        }

        @Override
        protected void ENTRY(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.EntryStart);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void EXIT(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.ExitStart);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.Transitions);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_EntryStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_EntryStart(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("An opening brace is expected after Entry.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StateStartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.EntryEnd);
                (context.getState()).entry(context);
                context.pushState(ActionMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_EntryEnd
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_EntryEnd(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void actionsDone(SmcParserContext context, List<SmcAction> actions, int lineNumber)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setEntryAction(actions);
            }
            finally
            {
                context.setState(ParserMap.StateStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void actionsError(SmcParserContext context)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.StartState);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_ExitStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_ExitStart(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("A opening brace is expected after Exit.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.StateStartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ExitEnd);
                (context.getState()).entry(context);
                context.pushState(ActionMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_ExitEnd
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_ExitEnd(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void actionsDone(SmcParserContext context, List<SmcAction> actions, int lineNumber)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setExitAction(actions);
            }
            finally
            {
                context.setState(ParserMap.StateStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void actionsError(SmcParserContext context)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.StateStart);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_Transitions
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_Transitions(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting either a new transition or a closing brace.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.TransError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void RIGHT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.addState();
            }
            finally
            {
                context.setState(ParserMap.States);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.storeTransitionName(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.TransStart);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_TransError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_TransError(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {

            return;
        }

        @Override
        protected void RIGHT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.addState();
            }
            finally
            {
                context.setState(ParserMap.States);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.storeTransitionName(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.TransStart);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_TransStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_TransStart(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting either a guard, \"push\", \"pop\", \"jump\" or end state.", ctxt.getLineNumber());
                ctxt.createTransition(ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.TransStartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void JUMP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createTransition(token.getLineNumber());
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
            }
            finally
            {
                context.setState(ParserMap.JumpStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_BRACKET(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createTransition(token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.TransGuard);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.TransParams);
            (context.getState()).entry(context);
            context.pushState(ParamMap.Start);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void POP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createTransition(token.getLineNumber());
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_POP);
            }
            finally
            {
                context.setState(ParserMap.PopStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void PUSH(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createTransition(token.getLineNumber());
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_PUSH);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.PushStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createTransition(token.getLineNumber());
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.SimpleTrans);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_TransStartError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_TransStartError(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {

            return;
        }

        @Override
        protected void JUMP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.JumpStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState("End state missing");
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).entry(context);
                context.pushState(ActionMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_BRACKET(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.TransGuard);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.TransParams);
            (context.getState()).entry(context);
            context.pushState(ParamMap.Start);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void POP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_POP);
            }
            finally
            {
                context.setState(ParserMap.PopStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void PUSH(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_PUSH);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.PushStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void RIGHT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.addGuard();
                ctxt.addTransition();
            }
            finally
            {
                context.setState(ParserMap.Transitions);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_TransParams
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_TransParams(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void paramsDone(SmcParserContext context, List<SmcParameter> params, int lineNumber)
        {
            SmcParser ctxt = context.getOwner();

            if (ctxt.getTransitionName().equalsIgnoreCase(
           "Default") == true &&
       params.isEmpty() == false)
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.error("Default transitions may not have parameters.", lineNumber);
                    ctxt.createTransition(params, lineNumber);
                }
                finally
                {
                    context.setState(ParserMap.TransNext);
                    (context.getState()).entry(context);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.createTransition(params, lineNumber);
                }
                finally
                {
                    context.setState(ParserMap.TransNext);
                    (context.getState()).entry(context);
                }

            }

            return;
        }

        @Override
        protected void paramsError(SmcParserContext context, List<SmcParameter> params, int lineNumber)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createTransition(params, lineNumber);
            }
            finally
            {
                context.setState(ParserMap.TransNext);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_TransNext
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_TransNext(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting either a guard, \"push\", \"pop\", \"jump\" or end state.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.TransNextError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void JUMP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.JumpStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_BRACKET(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.TransGuard);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void POP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_POP);
            }
            finally
            {
                context.setState(ParserMap.PopStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void PUSH(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_PUSH);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.PushStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.SimpleTrans);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_TransNextError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_TransNextError(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {

            return;
        }

        @Override
        protected void JUMP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.JumpStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_BRACKET(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.TransGuard);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            return;
        }

        @Override
        protected void POP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_POP);
            }
            finally
            {
                context.setState(ParserMap.PopStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void PUSH(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_PUSH);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.PushStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), "", token.getLineNumber());
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.SimpleTrans);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_TransGuard
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_TransGuard(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("[", "]");
            return;
        }

        @Override
        protected void exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        @Override
        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createGuard(ctxt.getTransitionName(), token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.EndState);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_EndState
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_EndState(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting either \"push\", \"pop\", \"jump\" or end state.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.EndStateError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void JUMP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.JumpStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void POP(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setTransType(TransType.TRANS_POP);
            }
            finally
            {
                context.setState(ParserMap.PopStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void PUSH(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setTransType(TransType.TRANS_PUSH);
                ctxt.setEndState("nil");
            }
            finally
            {
                context.setState(ParserMap.PushStart);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setTransType(TransType.TRANS_SET);
                ctxt.setEndState(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.SimpleTrans);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_EndStateError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_EndStateError(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {

            return;
        }

        @Override
        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).entry(context);
                context.pushState(ActionMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_SimpleTrans
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_SimpleTrans(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("An opening brace must proceed any action definitions.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.ActionStartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).entry(context);
                context.pushState(ActionMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void SLASH(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setTransType(TransType.TRANS_PUSH);
            }
            finally
            {
                context.setState(ParserMap.PushTransition);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_PushTransition
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PushTransition(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("\"push\" must follow a '/'.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.PushError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void PUSH(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.PushStart);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_PushStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PushStart(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("\"push\" must be followed by a '/'.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.PushError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.PushMap);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_PushError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PushError(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {

            return;
        }

        @Override
        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).entry(context);
                context.pushState(ActionMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.ActionStart);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_PushMap
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PushMap(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting a state name.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.PushError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setPushState(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.PushEnd);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_PushEnd
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PushEnd(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("push transition missing closing paren.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.PushError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.ActionStart);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_JumpStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_JumpStart(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("\"jump\" must be followed by a '/'.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.JumpError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.JumpMap);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_JumpError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_JumpError(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {

            return;
        }

        @Override
        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).entry(context);
                context.pushState(ActionMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.ActionStart);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_JumpMap
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_JumpMap(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting a state name.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.JumpError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setEndState(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.JumpEnd);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_JumpEnd
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_JumpEnd(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("jump transition missing closing paren.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.JumpError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.ActionStart);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_PopStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PopStart(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting '(trans)' or opening brace after pop.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.PopError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).entry(context);
                context.pushState(ActionMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.PopAction);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_PopError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PopError(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {

            return;
        }

        @Override
        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).entry(context);
                context.pushState(ActionMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.ActionStart);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_PopAction
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PopAction(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting either a pop transition or closing paren.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.PopError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.ActionStart);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setEndState(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.PopArgs);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_PopArgs
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PopArgs(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void COMMA(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.PopArgsEnd);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Pop transition missing closing paren.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.PopError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.ActionStart);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_PopArgsEnd
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_PopArgsEnd(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("(", ")");
            return;
        }

        @Override
        protected void exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        @Override
        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setPopArgs(token.getValue());
            }
            finally
            {
                context.setState(ParserMap.ActionStart);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_ActionStart
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_ActionStart(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("An opening brace must proceed any action definitions.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParserMap.ActionStartError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).entry(context);
                context.pushState(ActionMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_ActionEnd
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_ActionEnd(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void actionsDone(SmcParserContext context, List<SmcAction> actions, int lineNumber)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setActions(actions);
                ctxt.addGuard();
                ctxt.addTransition();
            }
            finally
            {
                context.setState(ParserMap.Transitions);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void actionsError(SmcParserContext context)
        {

            (context.getState()).exit(context);
            context.setState(ParserMap.Transitions);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParserMap_ActionStartError
        extends ParserMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParserMap_ActionStartError(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {

            return;
        }

        @Override
        protected void LEFT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createActionList();
            }
            finally
            {
                context.setState(ParserMap.ActionEnd);
                (context.getState()).entry(context);
                context.pushState(ActionMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    /* package */ static abstract class ParamMap
    {
    //-----------------------------------------------------------
    // Member methods.
    //

    //-----------------------------------------------------------
    // Member data.
    //

        //-------------------------------------------------------
        // Constants.
        //

        public static final ParamMap_Start Start =
            new ParamMap_Start("ParamMap.Start", 51);
        public static final ParamMap_Dollar Dollar =
            new ParamMap_Dollar("ParamMap.Dollar", 52);
        public static final ParamMap_ParamSeparator ParamSeparator =
            new ParamMap_ParamSeparator("ParamMap.ParamSeparator", 53);
        public static final ParamMap_ParamType ParamType =
            new ParamMap_ParamType("ParamMap.ParamType", 54);
        public static final ParamMap_NextParam NextParam =
            new ParamMap_NextParam("ParamMap.NextParam", 55);
        public static final ParamMap_Error Error =
            new ParamMap_Error("ParamMap.Error", 56);
    }

    protected static class ParamMap_Default
        extends SmcParserState
    {
    //-----------------------------------------------------------
    // Member methods.
    //

        protected ParamMap_Default(String name, int id)
        {
            super (name, id);
        }

    //-----------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParamMap_Start
        extends ParamMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParamMap_Start(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.createParamList();
            return;
        }

        @Override
        protected void DOLLAR(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (ctxt.getTargetLanguage() == TargetLanguage.PERL ||
       ctxt.getTargetLanguage() == TargetLanguage.PHP ||
       ctxt.getTargetLanguage() == TargetLanguage.GRAPH ||
       ctxt.getTargetLanguage() == TargetLanguage.TABLE)
            {
                (context.getState()).exit(context);
                // No actions.
                context.setState(ParamMap.Dollar);
                (context.getState()).entry(context);
            }
            else
            {
                super.DOLLAR(context, token);
            }

            return;
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParamMap.Error);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.popState();

            context.paramsDone(
            ctxt.getParamList(),
            token.getLineNumber());
            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createParameter(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParamMap.ParamSeparator);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParamMap_Dollar
        extends ParamMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParamMap_Dollar(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParamMap.Error);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createParameter("$" + token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ParamMap.ParamSeparator);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParamMap_ParamSeparator
        extends ParamMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParamMap_ParamSeparator(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void COLON(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.setState(ParamMap.ParamType);
            (context.getState()).entry(context);
            return;
        }

        @Override
        protected void COMMA(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (ctxt.getTargetLanguage() == TargetLanguage.TCL ||
       ctxt.getTargetLanguage() == TargetLanguage.GROOVY ||
       ctxt.getTargetLanguage() == TargetLanguage.JS ||
       ctxt.getTargetLanguage() == TargetLanguage.LUA ||
       ctxt.getTargetLanguage() == TargetLanguage.PERL ||
       ctxt.getTargetLanguage() == TargetLanguage.PHP ||
       ctxt.getTargetLanguage() == TargetLanguage.PYTHON ||
       ctxt.getTargetLanguage() == TargetLanguage.RUBY ||
       ctxt.getTargetLanguage() == TargetLanguage.GRAPH ||
       ctxt.getTargetLanguage() == TargetLanguage.TABLE)
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.addParameter();
                }
                finally
                {
                    context.setState(ParamMap.Start);
                    (context.getState()).entry(context);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.error("Parameter type missing.", token.getLineNumber());
                }
                finally
                {
                    context.setState(ParamMap.Error);
                    (context.getState()).entry(context);
                }

            }

            return;
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParamMap.Error);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (ctxt.getTargetLanguage() == TargetLanguage.TCL ||
       ctxt.getTargetLanguage() == TargetLanguage.GROOVY ||
       ctxt.getTargetLanguage() == TargetLanguage.JS ||
       ctxt.getTargetLanguage() == TargetLanguage.LUA ||
       ctxt.getTargetLanguage() == TargetLanguage.PERL ||
       ctxt.getTargetLanguage() == TargetLanguage.PHP ||
       ctxt.getTargetLanguage() == TargetLanguage.PYTHON ||
       ctxt.getTargetLanguage() == TargetLanguage.RUBY ||
       ctxt.getTargetLanguage() == TargetLanguage.GRAPH ||
       ctxt.getTargetLanguage() == TargetLanguage.TABLE)
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.addParameter();
                }
                finally
                {
                    context.popState();
                }


                context.paramsDone(
            ctxt.getParamList(),
            token.getLineNumber());
            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.error("Parameter type missing.", token.getLineNumber());
                }
                finally
                {
                    context.popState();
                }


                context.paramsError(
            ctxt.getParamList(),
            token.getLineNumber());
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParamMap_ParamType
        extends ParamMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParamMap_ParamType(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode2();
            return;
        }

        @Override
        protected void exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        @Override
        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setParamType(token.getValue());
            }
            finally
            {
                context.setState(ParamMap.NextParam);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParamMap_NextParam
        extends ParamMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParamMap_NextParam(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void COMMA(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.addParameter();
            }
            finally
            {
                context.setState(ParamMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Invalid parameter syntax.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ParamMap.Error);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.addParameter();
            }
            finally
            {
                context.popState();
            }


            context.paramsDone(
            ctxt.getParamList(),
            token.getLineNumber());
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ParamMap_Error
        extends ParamMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ParamMap_Error(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("(", ")");
            ctxt.clearParameter();
            return;
        }

        @Override
        protected void exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        @Override
        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.popState();

            context.paramsError(
            ctxt.getParamList(),
            token.getLineNumber());
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    /* package */ static abstract class ActionMap
    {
    //-----------------------------------------------------------
    // Member methods.
    //

    //-----------------------------------------------------------
    // Member data.
    //

        //-------------------------------------------------------
        // Constants.
        //

        public static final ActionMap_Start Start =
            new ActionMap_Start("ActionMap.Start", 57);
        public static final ActionMap_ActionName ActionName =
            new ActionMap_ActionName("ActionMap.ActionName", 58);
        public static final ActionMap_ActionArgs ActionArgs =
            new ActionMap_ActionArgs("ActionMap.ActionArgs", 59);
        public static final ActionMap_ActionEnd ActionEnd =
            new ActionMap_ActionEnd("ActionMap.ActionEnd", 60);
        public static final ActionMap_PropertyAssignment PropertyAssignment =
            new ActionMap_PropertyAssignment("ActionMap.PropertyAssignment", 61);
        public static final ActionMap_ActionError ActionError =
            new ActionMap_ActionError("ActionMap.ActionError", 62);
    }

    protected static class ActionMap_Default
        extends SmcParserState
    {
    //-----------------------------------------------------------
    // Member methods.
    //

        protected ActionMap_Default(String name, int id)
        {
            super (name, id);
        }

    //-----------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ActionMap_Start
        extends ActionMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ActionMap_Start(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.clearActions();
                ctxt.error("Expecting either a method name or a closing brace", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ActionMap.ActionError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void RIGHT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.popState();

            context.actionsDone(
            ctxt.getActionList(),
            token.getLineNumber());
            return;
        }

        @Override
        protected void WORD(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createAction(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ActionMap.ActionName);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ActionMap_ActionName
        extends ActionMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ActionMap_ActionName(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.clearActions();
                ctxt.error("Expecting an open paren after the method name", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ActionMap.ActionError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void EQUAL(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            if (ctxt.getTargetLanguage() != TargetLanguage.GRAPH &&
       ctxt.getTargetLanguage() != TargetLanguage.C_SHARP &&
       ctxt.getTargetLanguage() != TargetLanguage.GROOVY &&
       ctxt.getTargetLanguage() != TargetLanguage.JS &&
       ctxt.getTargetLanguage() != TargetLanguage.LUA &&
       ctxt.getTargetLanguage() != TargetLanguage.PERL &&
       ctxt.getTargetLanguage() != TargetLanguage.PYTHON &&
       ctxt.getTargetLanguage() != TargetLanguage.RUBY &&
       ctxt.getTargetLanguage() != TargetLanguage.SCALA &&
       ctxt.getTargetLanguage() != TargetLanguage.VB &&
       ctxt.getTargetLanguage() != TargetLanguage.TABLE)
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.clearActions();
                    ctxt.error("'=' property assignment may only be used with -vb, -csharp or -graph", token.getLineNumber());
                }
                finally
                {
                    context.setState(ActionMap.ActionError);
                    (context.getState()).entry(context);
                }

            }
            else
            {
                (context.getState()).exit(context);
                context.clearState();
                try
                {
                    ctxt.setProperty(true);
                    ctxt.createArgList();
                }
                finally
                {
                    context.setState(ActionMap.PropertyAssignment);
                    (context.getState()).entry(context);
                }

            }

            return;
        }

        @Override
        protected void LEFT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createArgList();
            }
            finally
            {
                context.setState(ActionMap.ActionArgs);
                (context.getState()).entry(context);
                context.pushState(ArgsMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ActionMap_ActionArgs
        extends ActionMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ActionMap_ActionArgs(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void argsDone(SmcParserContext context, List<String> args)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.setActionArgs(args);
            }
            finally
            {
                context.setState(ActionMap.ActionEnd);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void argsError(SmcParserContext context)
        {

            (context.getState()).exit(context);
            context.setState(ActionMap.ActionError);
            (context.getState()).entry(context);
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ActionMap_ActionEnd
        extends ActionMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ActionMap_ActionEnd(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Expecting a ';' after closing paren", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ActionMap.ActionError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void SEMICOLON(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.addAction();
            }
            finally
            {
                context.setState(ActionMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ActionMap_PropertyAssignment
        extends ActionMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ActionMap_PropertyAssignment(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode(";");
            return;
        }

        @Override
        protected void exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Missing ';' at end of property assignment", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ActionMap.ActionError);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createArgument(token.getValue(), token.getLineNumber());
                ctxt.addArgument();
                ctxt.setActionArgs(ctxt.getArgsList());
                ctxt.addAction();
            }
            finally
            {
                context.setState(ActionMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ActionMap_ActionError
        extends ActionMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ActionMap_ActionError(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void Default(SmcParserContext context)
        {

            return;
        }

        @Override
        protected void RIGHT_BRACE(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.popState();

            context.actionsError();
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    /* package */ static abstract class ArgsMap
    {
    //-----------------------------------------------------------
    // Member methods.
    //

    //-----------------------------------------------------------
    // Member data.
    //

        //-------------------------------------------------------
        // Constants.
        //

        public static final ArgsMap_Start Start =
            new ArgsMap_Start("ArgsMap.Start", 63);
        public static final ArgsMap_NextArg NextArg =
            new ArgsMap_NextArg("ArgsMap.NextArg", 64);
        public static final ArgsMap_Error Error =
            new ArgsMap_Error("ArgsMap.Error", 65);
    }

    protected static class ArgsMap_Default
        extends SmcParserState
    {
    //-----------------------------------------------------------
    // Member methods.
    //

        protected ArgsMap_Default(String name, int id)
        {
            super (name, id);
        }

    //-----------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ArgsMap_Start
        extends ArgsMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ArgsMap_Start(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode2();
            return;
        }

        @Override
        protected void exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        @Override
        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.createArgument(token.getValue(), token.getLineNumber());
            }
            finally
            {
                context.setState(ArgsMap.NextArg);
                (context.getState()).entry(context);
            }

            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ArgsMap_NextArg
        extends ArgsMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ArgsMap_NextArg(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void COMMA(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.addArgument();
            }
            finally
            {
                context.setState(ArgsMap.Start);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void Default(SmcParserContext context)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.error("Missing ',' or closing paren after argument.", ctxt.getLineNumber());
            }
            finally
            {
                context.setState(ArgsMap.Error);
                (context.getState()).entry(context);
            }

            return;
        }

        @Override
        protected void RIGHT_PAREN(SmcParserContext context, SmcLexer.Token token)
        {
            SmcParser ctxt = context.getOwner();

            (context.getState()).exit(context);
            context.clearState();
            try
            {
                ctxt.addArgument();
            }
            finally
            {
                context.popState();
            }


            context.argsDone( ctxt.getArgsList());
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }

    private static final class ArgsMap_Error
        extends ArgsMap_Default
    {
    //-------------------------------------------------------
    // Member methods.
    //

        private ArgsMap_Error(String name, int id)
        {
            super (name, id);
        }

        @Override
        protected void entry(SmcParserContext context)
            {
                SmcParser ctxt = context.getOwner();

            ctxt.setRawMode("{", "}");
            ctxt.clearArguments();
            return;
        }

        @Override
        protected void exit(SmcParserContext context)
            {
            SmcParser ctxt = context.getOwner();

            ctxt.setCookedMode();
            return;
        }

        @Override
        protected void SOURCE(SmcParserContext context, SmcLexer.Token token)
        {

            (context.getState()).exit(context);
            context.popState();

            context.argsError();
            return;
        }

    //-------------------------------------------------------
    // Member data.
    //

        //---------------------------------------------------
        // Constants.
        //

        private static final long serialVersionUID = 1L;
    }
}

/*
 * Local variables:
 *  buffer-read-only: t
 * End:
 */
